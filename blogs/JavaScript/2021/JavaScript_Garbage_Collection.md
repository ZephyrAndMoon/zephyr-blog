---
title: JavaScript 垃圾回收
date: 2021-04-11
tags:
 - JavaScript
 - 基础
categories: 
 - JavaScript
---

## 可达性



### 概念

JavaScript 中内存管理的主要概念是**可达性**。

拥有 **"可达性"** 值就是那些以某种方式可访问或可用的值，保证它们被存储在内存中。



**1. 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:**

- 本地函数的局部变量和参数
- 当前处于调用链上的其他函数的变量和参数
- 全局变量
- 还有一些其他的，内部的（变量或函数）



**2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。**

例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为**可达性**， 它引用的那些也是可以访问的。

JavaScript 引擎中有一个后台进程称为[垃圾回收器](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))，它监视所有对象，并删除那些不可访问的对象。



### 例子

```javascript
// user 具有对象的引用
let user = {
  name: "John"
};
```



![user](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809170332.png)



这里箭头表示一个对象引用。全局变量`“user”`引用对象 `{name:“John”}` (为了简洁起见，我们将其命名为**John**)。John 的 `“name”` 属性存储一个基本类型，因此它被绘制在对象中。

如果 `user` 的值被覆盖，则引用丢失:

```javascript
user = null;
```



![user=null](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809170503.png)



现在 **John** 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 **John** 数据并释放内存。



#### 两个引用

假设将引用从 `user` 复制到 `admin`:

```javascript
// user具有对象的引用
let user = {
  name: "John"
};

let admin = user;
```



![[Tworeferences](https://javascript.info/garbage-collection#two-references)](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171005.png)

现在如果做同样的事情:

```javascript
user = null;
```

该对象仍然可以通过 `admin` 全局变量访问，所以它依然在内存中。如果也覆盖`admin`，那么它可以被释放。



#### 相互关联的对象

现在来看一个更复杂的例子， family 对象：

```javascript
function marry (man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
})
```

函数 `marry` 通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象。

产生的内存结构:



![marry](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171324.png)



到目前为止，所有对象都是可访问的。

现在删除两个引用:

```javascript
delete family.father;
delete family.mother.husband;
```



![delete](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171404.png)

仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。

但是如果我们把这两个都删除，那么我们可以看到 **John** 不再有传入的引用:



![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171538.png)



输出引用无关紧要。只有传入的对象才能使对象可访问，因此，**John** 现在是不可访问的，并将从内存中删除所有不可访问的数据。

垃圾回收之后：

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411221042.png)



#### 无法访问的数据块

有可能整个相互连接的对象变得不可访问并从内存中删除。

源对象与上面的相同。然后:

```
family = null;
```

内存中的图片变成:

![familyIsNull](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809171753.png)



这个例子说明了可达性的概念是多么重要。

很明显，John和Ann仍然链接在一起，都有传入的引用。但这还不够。

`“family”`对象已经从根上断开了链接，不再有对它的引用，因此下面的整个块变得不可到达，并将被删除。



## 回收算法



### 标记 - 清除（Mark-Sweep）



#### 原理

**“标记 - 清除”**为基本的垃圾回收算法，定期执行以下"垃圾回收"步骤:

- 垃圾回收器获取根，遍历所有对象找可达对象（层级用递归进行操作），并**"标记"**(记住)它们。
  - 它访问并"标记"所有来自它们的引用。
  - 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
  - 以此类推，直到有未访问的引用(可以从根访问)为止。
- 除标记的对象外，所有对象都被清楚并抹掉第一阶段的标记
- 回收相应空间，将回收的空间加到空闲链表中，方便后面的程序申请空间使用



#### 例子

例如，对象结构如下:

![object](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172307.png)

我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看**“标记并清除”**垃圾回收器如何处理它。

**第一步标记根**

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172420.png)

**然后标记他们的引用**

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172431.png)

**以及子孙代的引用**

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172446.png)

现在进程中不能访问的对象被认为是不可访问的，将被删除：

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200809172458.png)



可以把这个过程想象成从根部洒下一大桶油漆，流经所有的参照物，并在所有可触及的对象上做标记。然后，未做标记的就会被清除。

这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。

标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。



**优点**

相对于引用计数算法来说解决对象循环引用的问题，局部作用域里面的内容无法被标记，所以即使有引用还是会被清除掉

**缺点**

空间链表地址不连续（空间碎片化），不能进行空间最大化使用



![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130114.png)

> 左边释放了`2`个字的空间，后边释放了`1`个字的空间，虽然看起来是释放了`3`个字的空间，但是地址是不连续的。如果要申请一个`1.5`字的空间，使用左边空间浪费了`0.5`，时候右边又不够，会造成无法最大化使用。





### 标记 - 整理（Mark-Compact）

在 **标记** 和 **清除** 中间，添加了内存空间的 **整理**



#### 原理

- 标记整理可以看做是标记清除的 **增强**
- 标记阶段：与标记清除一致
- 整理阶段：清除钱先执行整理，移动对象位置，在地址上产生连续
- 清除阶段：与标记清除一致



#### 例子

开始会有很多活动对象和非活动对象，还有一些空闲空间，回收前先开始整理

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130407.png)

整理之后要将非活动对象进行清除

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130425.png)

最后就留出了整个的空闲空间

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411130451.png)

**优点**

相较标记清除算法减少了碎片化空间

**缺点**

1. 压缩过程的开销，需要多次搜索堆
2. 不会立即回收垃圾对象，清除的时候程序是停止工作的。



### 引用计数（Reference Counting）

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

#### **示例**

```javascript
var o = {
  a: {
    b:2
  }
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
```



#### 限制：循环引用

该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

```javascript
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
// 要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空。可以这么做：
o = null;
o2 = null;
```

**实际例子：**

```javascript
var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
};
```

在上面的例子里，`myDivElement` 这个 DOM 元素里的 `circularReference 属性`引用了 `myDivElement`，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 `lotsOfData` 属性)，而这个数据占用的内存将永远不会被释放。





### 分代回收（Scavenge）

- **新生代** —— 就是指存活时间较短的对象，例如：一个局部作用域中，只要函数执行完毕之后变量就会回收。
- **老生代** —— 就是指存活时间较长的对象，例如：全局对象，闭包变量数据。



#### 内存分配

`V8`内存空间一分为二，分为新生代存储区和老生代存储区，如图：

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411132003.png)

- 左边小空间用于存储新生代对象
  - `64bit`操作系统上不超过`32M`
  - `32bit`操作系统上不超过`16M`
- 右边较大空间用于存储老生代对象
  - `64bit`操作系统上不超过`1.6G`
  - `32bit`操作系统上不超过`700M`



#### 新生代对象回收

##### 主要使用算法

采用赋值算法 + 标记整理算法

##### 回收过程

新生代内存区分为两个等大小空间，使用空间为`From`，空闲空间为`To`。

如果需要申请空间使用，回收步骤如下：

1. 首先会将所有活动对象存储于`From`空间，这个过程中`To`是空闲状态。
2. 当`From`空间使用到一定程度之后就会触发`GC`操作，这个时候会进行标记整理对活动对象进行标记并移动位置将使用空间变得连续，便于后续不会产生碎片化空间。
3. 将活动对象拷贝至`To`空间，拷贝完成之后活动空间就有了备份，这个时候就可以考虑回收操作了。
4. 把`From`空间完成释放，回收完成
5. 对`From`和`To`名称进行调换，继续重复之前的操作。

> 总结就是：
> `使用From` -> `触发GC标记整理` -> `拷贝到To` -> `回收From` -> `名称互换重复之前`

##### 晋升

拷贝的过程中某个对象的指代在老生代空间，就可能出现晋升。 **`晋升就是将新生代对象移动至老生代。`**

**什么时候触发晋升操作?**

> 1. 一轮`GC`之后还存活的新生代对象需要晋升
> 2. 在拷贝过程中，`To`空间的使用率超过`25%`，将这次的活动对象都移动至老生代空间

**为什么是限制To的使用率呢?**

> 将来回收操作是要把`From`空间的内容拷贝到`To`空间中进行交换，如果`To`的使用率太高，变成`From`之后新的对象就存不进去了。



#### 回收老生代对象

##### 主要使用算法

主要采用标记清除 **（首要）** 、标记整理、增量标记算法

- `标记清除`：虽然使用标记清除会有空间碎片化的问题，但是标记清除提升的速度是很快的。
- `标记整理`：在晋升的时候且老生代区域的空间也不够容纳的时候，就会采用标记整理进行 **空间优化**。
- `增量标记`：将一整段的垃圾回收操作标记拆分成多个小段完成回收，主要是为了实现程序和垃圾回收的交替完成，这样进行 **效率优化** 带来的时间消耗更加的合理。

##### 标记增量优化垃圾回收

看图可以将垃圾回收分成两个部分，一个是程序的执行，一个是垃圾的回收。当垃圾回收的时候其实会阻塞程序的执行，所以中间会有空档期。

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/20210411134207.png)

##### 新生代 VS 老生代

- 新生代区域垃圾回收使用**空间换时间**
  - 主要采用复制算法，要有空闲空间存在，当然新生代本身空间小，分出来的复制的空间更小，所以浪费这点空间换取时间的效率是微不足道的
- 老生代区域垃圾回收不适合复制算法，老生代空间大一分为二，会造成一半的空间浪费，存放数据多复制时间长。





### 增量标记（Incremental Marking）

- 前面的三种算法，都需要将正在执行的 JavaScript 应用逻辑暂停下来，待垃圾回收完毕后再恢复。这种行为叫作“全停顿”（stop-the-world）。

- 在 V8 新生代的分代回收中，只收集新生代，而新生代通常配置较小，且存活对象较少，所以全停顿的影响不大，而老生代就相反了。

- 为了降低全部老生代全堆垃圾回收带来的停顿时间，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直到标记阶段完成。

  ![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20200811005216.png)

  经过增量标记改进后，垃圾回收的最大停顿时间可以减少到原来的 1/6 左右。



## 参考

1. [垃圾回收机制认识与算法详解](https://segmentfault.com/a/1190000038461201)
2. [V8之旅：垃圾回收器](http://newhtml.net/v8-garbage-collection/)
3. [JavaScript引擎V8中的垃圾回收机制](https://segmentfault.com/a/1190000038461642)
4. [几种垃圾回收算法](https://www.jianshu.com/p/a8a04fd00c3c)

