---
title: Git Diff 算法
date: 2021-03-30
tags:
 - 杂
 - 算法
categories: 
 - Algorithm
---

## 1. 什么是直观的diff

diff 就是目标文本和源文本之间的区别，也就是将源文本变成目标文本所需要的操作。

举个简单的例子，源文本为 `ABCABBA`，目标文本为 `CBABAC`，他们之间的 diff 其实有无穷多种（我们以字符为单位，一般情况下是以行为单位）。比如：

```
1.  - A       2.  - A       3.  + C
    - B           + C           - A
      C             B             B
    - A           - C           - C
      B             A             A
    + A             B             B
      B           - B           - B
      A             A             A
    + C           + C           + C
```

上面三种都是有效的 diff，都可以将源文本变成目标文本，但是第二种和第三种没有第一种看起来“直观”。

所以需要个算法，生成"直观"的 diff，怎么样才叫"直观"呢？

- 当修改一块代码时，整块的删除然后新增，比删除新增交叉在一起要好，例如：

  ```
   Good: - one            Bad: - one
          - two                 + four
          - three               - two
          + four                + five
          + five                + six
          + six                 - three
  ```

- 新增或删除的内容应该和代码结构相呼应，例如下面的例子，左边我们可以很直观地看出新增了一个inspect 方法。

  ```
  Good: class Foo                   Bad:    class Foo
            def initialize(name)                def initialize(name)
              @name = name                        @name = name
            end                             +   end
        +                                   +
        +   def inspect                     +   def inspect
        +     @name                         +     @name
        +   end                                 end
          end                                 end
  ```

  除了直观以外，diff 还需要短，这一点是好理解的，我们希望 diff 反应的是把源文本变成目标文本需要用的最少的操作。



## 2. diff与图搜索

把"寻找最短的直观的 diff"这个非常模糊的问题抽象为一个具体的数学问题，然后再来寻找算法解决。

抽象的过程交给算法科学家了，抽象的结果是：**寻找 diff 的过程可以被表示为图搜索**。

以两个字符串，src=**ABCABBA**，dst=**CBABAC** 为例，根据这两个字符串可以构造下面一张图，横轴是 src 内容，纵轴是 dst 内容。



**图中每一条从左上角到右下角的路径，都表示一个 diff。向右表示"删除"，向下表示"新增"，对角线则表示"原内容保持不动"**

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20210330163314.png)

比如，选择这样一条路径：

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20210330165023.png)

"寻找 diff" 这件事，被抽象成了"寻找图的路径"了。"最短的直观的" diff 对应的路径的特点：

- 路径长度最短（对角线不算长度）
- 先向右，再向下（先删除，后新增）







## 3. Myers算法



### 3.1 三个概念

- **snake**: 一条 `snake` 代表走一步。例如从（0,0）->（0,1） / （0,0）->（1,0） / （0,1）->（0,2）->（2,4） 这分别为三条snake，**走对角线不计入步数**。
- **k line**: 定义 `k = x - y `（我们可以写成 `y = x - k`，是相同斜率的平行斜线组成的一个集合)
- **d contour**: 走一步算一个`d`



### 3.2 算法原理

Myers 算法就是一个能在大部分情况产生"最短的直观的"diff 的一个算法，算法原理如下：

首先，定义参数 `d` 和 `k`，d 代表路径的长度，`k` 代表当前坐标 `x - y` 的值。

定义一个"最优坐标"的概念，最优坐标表示 d 和 k 值固定的情况下，**x 值最大的坐标**。x 大，表示向右走的多，表示优先删除。



以上面那张图为例。从坐标 `(0, 0)` 开始，此时，`d=0`，`k=0`，然后逐步增加 `d`，计算每个 `k` 值下对应的最优坐标。



因为每一步要么向右`（x + 1）`，要么向下`（y + 1）`，对角线不影响路径长度，所以，当 d=1 时，k 只可能有两个取值，要么是 `1`，要么是 `-1`。

- 当 `d=2`，`k=-2` 时，最优坐标是 `(2, 4)`。

- 当 `d=2`，`k=0` 时，最优坐标是 `(2, 2)`。

- 当 `d=2`，`k=2` 时，最优坐标是 `(3, 1)`。

以此类推，直到我们找到一个 `d` 和 `k` 值，达到最终的目标坐标 `(7, 6)`。



下图横轴代表 `d`，纵轴代表 `k`，中间是最优坐标，从这张图可以清晰的看出，当 `d=5`，`k=1` 时，我们到达了目标坐标 （7, 6）

![](https://markdowncun.oss-cn-beijing.aliyuncs.com/markdown/20210330164509.png)

因此，"最短的直观的"路径就是 `(0, 0) -> (1, 0) -> (3, 1) -> (5, 4) -> (7, 5) -> (7, 6)`，对应的 diff 如下。

```
- A
- B
  C
+ B
  A
  B
- B
  A
+ C
```



Myers 算法是一个典型的”动态规划“算法，也就是说，父问题的求解归结为子问题的求解。要知道 d=5 时所有 k 对应的最优坐标，必须先要知道 d=4 时所有 k 对应的最优坐标，要知道 d=4 时的答案，必须先求解 d=3，以此类推，和 01 背包问题很是相似。



## 4. 实现

[myers-diff](https://github.com/cj1128/myers-diff)

基本流程：

1. 迭代 d，d 的取值范围为 0 到 n+m，其中 n 和 m 分别代表源文本和目标文本的长度（这里我们选择以行为单位）
2. 每个 d 内部，迭代 k，k 的取值范围为 -d 到 d，以 2 为步长，也就是 -d，-d + 2，-d + 2 + 2…
3. 使用一个字典 v，以 k 值为索引，存储最优坐标的 x 值
4. 将每个 d 对应的 v 字典存储起来，后面回溯的时候需要用
5. 当我们找到一个 d 和 k，到达目标坐标 (n, m) 时就跳出循环
6. 使用上面存储的 v 字典（每个 d 对应一个这样的字典），从终点反向得出路径



> Git 真正用的是标准 Myers 算法的一个变体。标准的算法有一个很大的缺点，就是空间消耗很大，因为我们需要存储每一个 `d` 对应的 `v` 字典。如果输入文件比较大，这样的空间开销是不能接受的。因此 Myers 在他的 [论文](http://www.xmailserver.org/diff2.pdf) 中，同时提供了一个算法变体，这个变体需要的空间开销要小得多。但是在某些情况下，变体产生的 diff 会和标准算法有所不同。也就是说，如果你按照上面的算法实现的程序，出来的结果和 `git diff` 的结果有所不同是正常的。



## 5. 参考资料

- [The Myers diff algorithm: part 1](https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/)
- [An O(ND) Difference Algorithm and Its Variations](http://xmailserver.org/diff2.pdf)
